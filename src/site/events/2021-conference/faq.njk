---
layout: layouts/_base.njk
title: Conference
headerText: A New Era of Democracy
bodyText: |
  **HOW DOES AN OPEN SPACE UNCONFERENCE WORK?**

  The Open Space unConference format creates space for peer-to-peer learning, collaboration and creativity. Open Space is a way to bring people who have a shared interest or who want to collaborate or work on something together.

  **「開放空間會議」是如何運作的？**

  開放空間會議的形式能夠創造出同儕學習、合作與創意的環境。開放空間很適合讓擁有共同興趣的人，或是想要一起合作做些什麼的人，共同聚集起來解決問題。

  **HOW DOES IT WORK IF THERE ISN'T A PRE-SET AGENDA?**

  Open Space facilitates an agenda creation process at the beginning of the day so that all those gathered can put forward ideas for sessions. Because the agenda is made live in real time it is of direct relevance to those gathered that day (or at least for the person calling the session).

  It is virtually impossible to figure out the topics that will be hot and need face time for discussion six months, three months or even one month prior to an event.  Even if there is a committee of 1 or 3 or 10 they can’t ‘know’ all of what 50-600 people coming from different areas to an event around a topic need or want to talk about ahead of time.

  Live agenda creation makes effective use of face-to face-time during the day of the conference instead of around the edges of events programmed many months ahead of time.

  **活動沒有議程要怎麼進行？**

  開放空間會議的議程是由所有參與者在活動開始一起討論出來的，而討論中所集結的點子則會成為後續討論的主題。因為議程都是現場形成的，所以內容都是參與者所關心的主題。

  我們一般很難在活動前半年、三個月、甚至一個月前找出人們關心什麼熱門話題。即便是面對面討論，組成一人、三人或十人小組，也無法全盤知道來自不同地區 50-600 人的共同想法。

  即時議程創造能夠有效地運用活動中面對面的時間，跟參與者直接討論，而不是花好幾個月的時間猜測人們究竟對什麼話題有興趣。

  **HOW WILL I KNOW WHAT WILL BE DISCUSSED IF THERE ISN'T A PRE-SET AGENDA?**

  When people register we ask them about what they might present or share, and what they are hoping to learn and discuss with peers.

  You can see those answers here from those who already registered:

  [Taipei Discussion Topics](/2021-conference/taipei/#topics)

  [Online Discussion Topics](/2021-conference/online/#topics)

  [Denver Discussion Topics](/2021-conference/denver/#topics)

  **要怎麼知道活動沒有事先安排的議程？**

  當參與者報名活動的時候，我們會事先詢問他們預計分享的內容，或是他們希望能夠跟其他參與者一起討論、學習的是什麼。

  你可以從這邊看到已經報名的人他們希望討論的話題：

  [台北場討論主題](/2021-conference/taipei/#topics)

  [線上活動討論主題](/2021-conference/online/#topics)

  [丹佛場討論主題](/2021-conference/denver/#topics)

  **HOW DOES AGENDA CREATION WORK?**

  Agenda creation is part of the Opening Circle at the start of the day and will be explained completely at that time by the Open Space Facilitator.

  In both the online and virtual version of Open Space there is a blank Agenda Wall with time slots and multiple breakout spaces/rooms affiliated with each time slot. The facilitator will invite those who have a session they want to call, something they want to talk about related to the overall theme, come to the front and write on an 8×11 sheet of cardstock the title of the topic and their name.  Or in a virtual circle to raise their hand and be called on to share the title of the session.

  Once announced to the whole room they will put in a slot on the blank schedule. This goes on for about 15-30 min and voila now the attendees have co-created a full schedule. Those gathered then break up and go to the sessions they want.

  **議程創造是如何進行的？**

  每場開放空間會議一剛開始，會先邀請參與者共同圍成圓圈，討論整場活動的會議流程，過程中會由引導師協助講解與主持。

  在線上的開放空間會議中，也會設置一個空白的會議流程牆，上頭會標示議程時段、分組空間與討論時間。接著引導師會邀請想要召集討論的參與者，分享他們想要討論且跟活動有關的議題，並上前把主題名稱與姓名寫在 8x11 的卡片上。或是大家可以在線上的虛擬圓圈中舉手，等到被引導師叫到的時候分享。

  一旦當有參與者跟大家宣佈他提出的討論主題，就會直接新增在空白的議程上，直到參與者共同討論出整場活動的議程。這個過程通常會需要 15-30 分鐘。結束後，參與者就可以分組進行接下來的討論。

  **WHAT DO I NEED TO DO TO CONVENE A SESSION?**

  Really all you need is the spark of interest/passion.  You do not need to do preparation in order to convene a session. If you get an idea the day of the event, call a session.

  **召集一場小組討論需要做什麼？**

  說真的，你只需要帶著你的興趣與熱情來，不需要多做其他的準備。如果你想到什麼點子，就直接發起一場討論吧！

  **WHAT TYPES OF SESSIONS HAPPEN AT UNCONFERENCES?**

  The sessions convened will range from the formal to the informal:
  - From the well thought out pre-prepared talk reflecting years of research and practice to the spur of the moment ‘new idea’ that would be fun to talk about.
  - From the demonstration of a working tool to the whiteboarding of something completely new to a question related to the event theme.
    - ***The longer formal presentation:***
    This is tricky, because it’s difficult to make a formal presentation interactive. But if you have a big, well-developed idea you can pull it off as long as you still leave time for questions and interaction at the end.
    - ***A short presentation to get things started:***
    5-15 minutes of prepared material/comments by the session leader followed by an interactive discussion
    - ***Group discussion:***
    Someone identifies a topic they are interested in, others come to join the conversation and an interesting discussion happens
    - ***My Big (or Little) Question:***
    You have a question you want to know the answer to, and you think others in the group could help you answer it. This format could also just be the seed of a conversation.
    - ***Show and tell:***
    You have a cool project, a demo, or just something to show and let people play with that is the springboard for all the conversation in the session. Alternatively, you can invite others to bring their own items to show and tell (perhaps with a theme), and everyone takes a turn sharing.
    - ***Learn how to do X:***
    If you’re inclined to teach, this can be simple and effective. Bring the equipment that you need, and have a plan that will let you teach five, ten, or 15 people how to do something all at the same time.

  **開放空間會議中有哪些小組討論類型**

  本次小組討論包含正式與非正式的形式：
  - 不管是從經過深思熟慮、提前準備多年的研究或實踐，到靈機一動激發出的有趣想法，都可以成為討論主題。
  - 從工具展示，到在空白的白板上展開跟主題相關的問題
    - ***長時間正式報告:***
    這點比較棘手，因為正式報告會使互動變得困難。不過如果你有一個宏大且成熟的想法，你還是可以好好陳述你的內容，只要記得在最後留下問答互動的時間。
    - ***一段簡短的開場白:***
    小組召集人可以先準備 5-15 分鐘的討論素材，接著就可以進入到互動討論的環節。
    - ***團體討論：***
    有人找到他們感興趣的主題，其他人加入了討對話，一場有趣的討論就這麼開始了。
    - ***大／小問題：***
    你心中有個問題想要尋求解答，而你認為小組成員中也許有人可以回答。這個模式同樣也能夠成為一場對話的起點。
    - ***展示與講述：***
    不管是你有一個很酷的計畫、樣本，或是只是一些可以秀出來給人玩玩看的東西，這些都能夠成為展開對話的跳板。另一方面，你可以邀請其他人帶他們自己想要展現的東西或主題，讓每個人輪流分享。
    - ***學習怎麼做Ｘ：***
    如果你想要教別人，這是簡單且有效的方法。只要帶上你所需要的器材，制定一個同時教授 5-15 人的授課計畫。

  **HOW ARE SESSIONS DOCUMENTED?**

  When conveners host a session we ask them to work with the participants to take notes in the session. Each session has its own HackMD online document and posters. After the event is complete the notes from each session are compiled into a Book of Proceedings.

  **如何記錄討論會議的內容？**

  會議召集人主持會議時，會在一開始找參與者做會議記錄。每場小組討論會使用 HackMD 共筆系統或海報個別紀錄。活動結束後，主辦單位會協助整合討論內容。

  **BEST PRACTICES FOR PARTICIPATING IN AN OPEN SPACE UNCONFERENCE**

  ***Go with the flow*** – This event is intended to help you and all the other people find the time and space to talk with and learn from each other.

  ***Follow your passion*** – Go to the sessions that interest you.

  ***Take responsibility for your own learning*** – If there are topics you are really interested in that don’t appear on the agenda at first, you need to put them on there.

  **參與開放空間會議的最佳示範**

  **順其自然:** 開放空間會議的活動目的是希望能夠幫助你和其他人，找到時間和空間來互相交流與學習。

  **跟隨你的熱忱:** 加入那些你感興趣的討論小組

  **為你的學習負責:** 如果議程上沒有你真正感興趣的主題，那你就應該要主動提出來。

  **WHERE DID THE TERM "UNCONFERENCE" COME FROM?**

  The term “unconference” arose as people in the technology industry started making conferences (using the principles of Open Space originated by Harrison Owen in ) that stepped out of the traditional models, which had involved presentations selected months beforehand, panels of speakers, industry sponsors talking about their products, and “trade show” exhibits.

  **「非正式會議」一詞是怎麼來的？**

  「非正式會議」這個詞最早是從科技業的研討會中誕生，像是 Harrison Owen 設計出開放空間會議的規則，都是一種跳脫傳統討論會議的模式。不再需要事前長時間的議程規劃、邀請與談來賓、贊助商置入，或是安排貿易展會。

  **DO ALL UNCONFERENCES USE OPEN SPACE TECHNOLOGY?**

  No, there are a variety of different interactive methods that all fall under the large umbrella of unconference methods including World Cafe, Spectrogram, Fishbowl amongst others. The key thing they all have in common is that they support participants interacting with each other and in ways that are alive and present and don’t have a pre-set agenda with talking heads.

  **所有的「非正式會議」都會使用開放空間技術嗎？**

  不是。「非正式會議」的互動形式有很多種，像是世界咖啡館、分組模式、討論圈等模式。這些互動方法的共通點在於他們都鼓勵參與者投入在當下的討論，而且不會提前規劃討論的主題流程。

  **WHERE DOES OPEN SPACE TECHNOLOGY COME FROM?**

  Open space was originated by Harrison Owen in 1985.  It works best when the work to be done is complex, the people and ideas involved are diverse, the passion for resolution (and potential for conflict) are high, and the time to get it done was yesterday.  It's been called passion bounded by responsibility, the energy of a good coffee break, intentional self-organization, spirit at work, chaos and creativity, evolution in organization, and a simple, powerful way to get people and organizations moving -- when and where it's needed most.  For more information check out Harrison’s book: *Open Space Technology - A Users Guide*

  **開放空間會議技術源自哪裡？**

  開放空間會議是由 Harrison Owen 在 1985 年所設計。這項技術尤其適用於面臨處理複雜問題，當參與成員與想法來自不同背景，大家對解決問題的熱忱（或是潛在衝突程度）很高，卻對解決方法毫無頭緒。開放空間會議強調參與者的熱忱與責任，以一種簡單而有力的方法，在最需要的時候和地方動起來，像是為咖啡休息時間帶來好的能量、有意識進行自我組織、職場靈性、混亂與創造力，或是推動組織再造等情境。如果想要了解更多資訊，請參閱 Harrison Owen 的著作《開放空間會議技術：使用者指南》。
---

<!-- prettier-ignore -->
{% import "components/introduction.njk" as introduction %}
<!-- prettier-ignore -->
{% import "components/action-button.njk" as actionButton %}
<!-- prettier-ignore -->
{% import "components/logo.njk" as logo %}
<!-- prettier-ignore -->
{% import "components/conference-menu.njk" as menu %}
<!-- prettier-ignore -->
{% import "components/footer.njk" as footer %}

<!-- prettier-ignore -->
{{ menu.render() }}
<!-- prettier-ignore -->
<div
  class="relative grid grid-cols-layout-4 lg:grid-cols-layout-12 grid-rows-auto/auto content-between min-h-screen bg-golden-fizz py-margin lg:py-lg/margin"
>
  <div id="sidebar" class="conference_menu">
    <div class="w-full">
      <button class="bg-black w-full">
        <a href="/2021-conference">
          <h1 class="font-display uppercase text-center my-4 text-size-4 text-white">
            2021 Annual Conference
          </h1>
        </a>
      </button>
    </div>
    <div class="mb-auto ml-4 mr-8 text-center">
      <button class="conference_button">
        <a href="/2021-conference/taipei">
          <p class="text-white uppercase text-size--2 m-2">Taipei Event</p>
        </a>
      </button>
      <button class="conference_button">
        <a href="/2021-conference/online">
          <p class="text-white uppercase text-size--2 m-2">Online Event</p>
        </a>
      </button>
      <button class="conference_button">
        <a href="/2021-conference/denver">
          <p class="text-white uppercase text-size--2 m-2">Denver Event</p>
        </a>
      </button>
      <button class="conference_button">
        <a href="/events/2021-conference/faq">
          <p class="text-white uppercase text-size--2 m-2">FAQ</p>
        </a>
      </button>
    </div>
  </div>
  <header class="col-span-columns mb-8">
    <a href="/">
      {{ logo.render(classes="hidden lg:inline-block align-top") }}
    </a>
    <h1 class="font-display uppercase mt-32 text-size-display lg:text-size-xl/display">
      FAQ
    </h1>
  </header>
  <div
    class="col-span-columns lg:col-start-column-1 lg:col-end-column-8 space-y-line-3/2"
  >
    <div class="markdown markdown-sm mb-12">
      {{ bodyText | markdown | safe }}
    </div>
    {{ caller() if caller }}
  </div>
</div>
<!-- prettier-ignore -->
{{ footer.render() }}
<script>
/* Menus */

const Menu = function ($menu) {
  this.$menu = $menu;
  this.$menuInner = $menu.querySelector("#menu_inner");

  this.menuItems = [];
  this.firstItem = null;
  this.lastItem = null;
  this.isOpen = false;

  this.openAnimationTimer = null;
  this.closeAnimationTimer = null;
  this.handleMouseLeave = this._handleMouseLeave.bind(this);
  this.handleTouchOutside = this._handleTouchOutside.bind(this);
};

Menu.prototype.init = function () {
  let menuElements = this.$menu.querySelectorAll("[data-menu-item]");
  for (let menuElement of menuElements) {
    let menuItem = new MenuItem(menuElement, this);
    menuItem.init();
    this.menuItems.push(menuItem);
  }

  let numItems = this.menuItems.length;
  if (numItems > 0) {
    this.firstItem = this.menuItems[0];
    this.lastItem = this.menuItems[numItems - 1];
  }
};

Menu.prototype.setFocusToItem = function (newItem) {
  for (let menuItem of this.menuItems) {
    menuItem.blur();
  }
  newItem.focus();
};

Menu.prototype.setFocusToFirstItem = function () {
  this.setFocusToItem(this.firstItem);
};

Menu.prototype.setFocusToLastItem = function () {
  this.setFocusToItem(this.lastItem);
};

Menu.prototype.setFocusToPreviousItem = function (currentItem) {
  let newItem;
  if (currentItem === this.firstItem) {
    newItem = this.lastItem;
  } else {
    let index = this.menuItems.indexOf(currentItem);
    newItem = this.menuItems[index - 1];
  }
  this.setFocusToItem(newItem);
};

Menu.prototype.setFocusToNextItem = function (currentItem) {
  let newItem;
  if (currentItem === this.lastItem) {
    newItem = this.firstItem;
  } else {
    let index = this.menuItems.indexOf(currentItem);
    newItem = this.menuItems[index + 1];
  }
  this.setFocusToItem(newItem);
};

Menu.prototype._handleTouchOutside = function (event) {
  if (this.$menuInner.contains(event.target)) {
    return;
  }
  this.close();
};

Menu.prototype._handleMouseLeave = function (event) {
  if (event.relatedTarget === null) {
    return;
  }
  this.close();
};

Menu.prototype.open = function () {
  if (this.isOpen) {
    return;
  }

  this.$menuInner.classList.remove("hidden");
  this.$menu.classList.add("menu_open");
  this.openAnimationTimer = setTimeout(() => {
    this.openAnimationTimer = null;
    document.addEventListener("touchstart", this.handleTouchOutside);
    this.$menuInner.addEventListener("mouseleave", this.handleMouseLeave);
    bodyScrollLock.disableBodyScroll(this.$menuInner);
    this.isOpen = true;
  }, 550);
};

Menu.prototype.close = function () {
  if (!this.isOpen) {
    return;
  }

  this.$menuInner.removeEventListener("mouseleave", this.handleMouseLeave);
  document.removeEventListener("touchstart", this.handleTouchOutside);
  this.$menu.classList.remove("menu_open");
  this.closeAnimationTimer = setTimeout(() => {
    this.closeAnimationTimer = null;
    this.$menuInner.classList.add("hidden");
    bodyScrollLock.enableBodyScroll(this.$menuInner);
    this.isOpen = false;
  }, 550);
};

/* MenuButton */

const MenuButton = function ($button, menu) {
  this.$button = $button;
  this.menu = menu;

  this.keyCode = Object.freeze({
    TAB: 9,
    RETURN: 13,
    ESC: 27,
    SPACE: 32,
    PAGEUP: 33,
    PAGEDOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
  });
};

MenuButton.prototype.init = function () {
  this.$button.addEventListener("keydown", this.handleKeyDown.bind(this));
  if (this.$button.dataset.menuButton === "hover") {
    this.$button.addEventListener("touchstart", this.handleClick.bind(this));
    this.$button.addEventListener(
      "mouseenter",
      this.handleMouseEnter.bind(this)
    );
  } else {
    this.$button.addEventListener("click", this.handleClick.bind(this));
  }
};

MenuButton.prototype.handleKeyDown = function (event) {
  let flag = false;

  switch (event.keyCode) {
    case this.keyCode.SPACE:
    case this.keyCode.RETURN:
    case this.keyCode.DOWN:
      this.menu.open();
      this.menu.setFocusToFirstItem();
      flag = true;
      break;
    case this.keyCode.UP:
      this.menu.open();
      this.menu.setFocusToLastItem();
      flag = true;
      break;
    default:
      break;
  }

  if (flag) {
    event.stopPropagation();
    event.preventDefault();
  }
};

MenuButton.prototype.handleMouseEnter = function (event) {
  if (!this.menu.isOpen) {
    this.menu.open();
    this.menu.setFocusToFirstItem();
  }
  event.stopPropagation();
  event.preventDefault();
};

MenuButton.prototype.handleClick = function (event) {
  if (this.menu.isOpen) {
    this.menu.close();
  } else {
    this.menu.open();
    this.menu.setFocusToFirstItem();
  }
  event.stopPropagation();
  event.preventDefault();
};

/* MenuItem */

const MenuItem = function ($item, menu) {
  this.$item = $item;
  this.menu = menu;

  this.keyCode = Object.freeze({
    TAB: 9,
    RETURN: 13,
    ESC: 27,
    SPACE: 32,
    PAGEUP: 33,
    PAGEDOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
  });
};

MenuItem.prototype.init = function () {
  this.$item.tabIndex = -1;
  this.$item.addEventListener("keydown", this.handleKeydown.bind(this));
};

MenuItem.prototype.handleKeydown = function (event) {
  if (event.ctrlKey || event.altKey || event.metaKey) {
    return;
  }

  let flag = false;
  switch (event.keyCode) {
    case this.keyCode.UP:
      this.menu.setFocusToPreviousItem(this);
      flag = true;
      break;
    case this.keyCode.DOWN:
      this.menu.setFocusToNextItem(this);
      flag = true;
      break;
    case this.keyCode.HOME:
    case this.keyCode.PAGEUP:
      this.menu.setFocusToFirstItem();
      flag = true;
      break;
    case this.keyCode.END:
    case this.keyCode.PAGEDOWN:
      this.menu.setFocusToLastItem();
      flag = true;
      break;
    case this.keyCode.ESC:
      this.menu.close();
      flag = true;
      break;
    case this.keyCode.TAB:
      this.menu.close();
      break;
    default:
      break;
  }

  if (flag) {
    event.stopPropagation();
    event.preventDefault();
  }
};

MenuItem.prototype.blur = function () {
  this.$item.tabIndex = -1;
};

MenuItem.prototype.focus = function () {
  this.$item.tabIndex = 0;
  this.$item.focus();
};

/* Attachment code */
const menu = new Menu(document.querySelector("#menu"));
menu.init();

for (const $menuButton of document.querySelectorAll("[data-menu-button]")) {
  const menuButton = new MenuButton($menuButton, menu);
  menuButton.init();
}

/* Hide buttons when you scroll to footer */
const $footer = document.getElementById("footer");
const $sidebar = document.getElementById("sidebar");
const $theMenuSlider = document.getElementById("menu_slider");
const $theMenuButton = document.getElementById("menu_button");
const disappearObserver = new IntersectionObserver(
  (entries) => {
    entries.forEach((entry) => {
      if (entry.intersectionRatio >= 0.1) {
        $theMenuButton.classList.add("menu_button-closed");
        $sidebar.style.position = "absolute";
      } else {
        $theMenuButton.classList.remove("menu_button-closed");
        $sidebar.style.position = "fixed";
      }
      if (entry.intersectionRatio >= 0.5) {
        $theMenuSlider.classList.add("menu_slider-closed");
        $sidebar.style.position = "absolute";
      } else {
        $theMenuSlider.classList.remove("menu_slider-closed");
        $sidebar.style.position = "fixed";
      }
    });
  },
  { threshold: [0.1, 0.5] }
);
disappearObserver.observe($footer);
</script>
